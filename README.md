# Генератор С++ тестов для автоматического измерения производительности ASM и С/С++ функций на процессорах NeuroMatrix


## Назначение
На основе заданного для каждой функции сценария данный генератор позволяет замерить время исполнения функций и создать текстовый файл отчета.  
Средство позволяет протестировать производительность функции в разных конфигурациях запуска в зависимости от размера данных и взаимного расположений массивов данных в доступных внутренних и внешних банках памяти. По данным тестирования можно судить о полном времени работы функции, об удельной производительности функции в пересчете на входной элемент данных, а также о наиболее оптимальных конфигурациях с точки зрения расположения входных, выходных и временных массивов по банкам памяти. 
Средство полезно при разработке, оптимизации и тестировании функций, а также для подготовки данных по производительности при импорте в техническую документацию.  
Средство  поддерживает автоматизацию для обработки большого кол-ва функций, генерации тестов и их последующего запуска. 
Описанные сценария тестирования задаются непосредственно в заголовочных файлах в виде комментариев к функциям в формате Doxygen. 
Результат замеров выдается в табличном виде в формате MarkDown.

## Как это работает
Допустим имеется функция сложения двух векторов:
```
void nmppsAdd_32f(const nm32f* pSrcVec1, const nm32f* pSrcVec2, nm32f* pDstVec, int nSize);
```

и есть несколько буферов , расположенных в разных банках внутренней памяти (imu1-imu6), и внешней DDR (emi):
```
#pragma data_section ".data_imu1"
    long long im1[2048];
#pragma data_section ".data_imu2"
    long long im2[2048];
#pragma data_section ".data_imu3"
    long long im3[2048];

#pragma data_section ".data_emi"
    long long emi[2048];
```

Задача 1: требуется замерять время исполнения функции в следующих вариантах памятей при фиксированном размере, чтобы найти лучшую конфигурацию :

nmppsAdd_32f(im1,im1,im1,256);  
nmppsAdd_32f(im1,im2,im1,256);  
nmppsAdd_32f(im2,im1,im1,256);  
nmppsAdd_32f(im2,em2,im1,256);  
nmppsAdd_32f(im1,im1,im2,256);  
nmppsAdd_32f(im1,im2,im2,256);  
nmppsAdd_32f(im2,im1,im2,256);  
nmppsAdd_32f(im2,em2,im3,256);  
nmppsAdd_32f(im1,im1,im3,256);  
nmppsAdd_32f(im1,im2,im3,256);  
nmppsAdd_32f(im2,im1,im3,256);  
nmppsAdd_32f(im2,em2,im3,256);  

Задача 2: требуется определить скорость работы функции в зависимости от размера данных, при фиксированном расположении :

nmppsAdd_32f(im1,im2,im3,8;  
nmppsAdd_32f(im1,im2,im3,128);  
nmppsAdd_32f(im1,im2,im3,1024);  
nmppsAdd_32f(im1,im2,im3,2048);  


В случае ручного выполнения данной задачи (написание тестов, сборка , запуск , сбор информации) процесс будет очень трудоемким, в котором при каждой модификации кода потребуется повторный перезапуск тестов. 
Решение данной  задачи  может быть полностью автоматизировано с помощью генератора тестов test_perf следующим образом:

К функции составляется описание ее параметров в формате Doxygen, в которое в XML-виде добавляются сценарии, по которым необходимо перебирать переменные :

```
/**
\defgroup nmppsAdd_f nmppsAdd
\brief Сложение двух векторов.
\param pSrcVec1 [in] Первый входной вектор.
\param pSrcVec2 [in] Второй входной вектор.
\param nSize [in] Размер вектора в элементах.
\retval pDstVec [out] Результирующий вектор.
\par
\xmlonly
    <testperf>
         <param name=" pSrcVec1 "> im1 im2 </param>
         <param name=" pSrcVec2 "> im1 im2 </param>
         <param name=" pDstVec "> im1 im2 im3 </param>
         <param name=" nSize "> 2048 </param>
    </testperf>
    <testperf>
         <param name=" pSrcVec1 "> im1 </param>
         <param name=" pSrcVec2 "> im2 </param>
         <param name=" pDstVec "> im3 </param>
         <param name=" nSize "> 8 128 1024 2048 </param>
    </testperf>
\endxmlonly
*/
//! \{
void nmppsAdd_32f(const nm32f* pSrcVec1, const nm32f* pSrcVec2, nm32f* pDstVec, int nSize);
//! \}
```

Создается проект-заготовка теста, состоящего из пустой функции main() , сборочного файла Makefile и сборочного конфигурационного файла (cfg или ld). Программа должна собираться и исполняться , командам make и make run соответственно. 
```
#include "nmpp.h"
#include "time.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"

#pragma data_section ".data_imu1"
    long long im1[2048];
#pragma data_section ".data_imu2"
    long long im2[2048];
#pragma data_section ".data_imu3"
    long long im3[2048];

int main()
{
  return 0;
}
```

Далее запускается генератор test_perf c указанием  пути к заголовочным файлам и папке с проектом-заготовкой:
```
testperf config -i ..\include  -b make_mc12101_nmpu0
```

Генератор test_perf запустит Doxygen и затем создаст для всех найденных (описанных в Doxygen) функций тестовые проекты. В нашем случае для функции nmppsAdd_32f создаст папку \perf_nmppsAdd_32f с тестом main.cpp  .


В результате в main.cpp будет сгенерирован С++ код, перебирающий по сценарию все варианты запуска и производящий для каждого замер времени: 

```
int main(){
  ...
  long long* list0[] = {im1, im2};
  long long* list1[] = {im1, im2};
  long long* list2[] = {im1, im2, im3};
  time_t t1, t2;

  for(int i0 = 0; i0 < 2; i0++) {
    nm32f * pSrcVec1 = (nm32f *)list0[i0];
    for(int i1 = 0; i1 < 2; i1++) {
      nm32f * pSrcVec2 = (nm32f *)list1[i1];
      for(int i2 = 0; i2 < 3; i2++) {
        nm32f * pDstVec = (nm32f *)list2[i2];
        int nSize = (int)(2048);
        
        t1 = clock();
        nmppsAdd_32f(pSrcVec1, pSrcVec2, pDstVec, nSize);
        t2 = clock();
        ...
      }
    }
  }
  ...
}   
```


После генерации тестов осуществляется сборка и запуск тестов командой 
```
testperf run
```

Test_perf запустит все имеющиеся тесты и выдаст файл nmppsAdd_32f.md с таблицей замеров производительности следующего вида:


pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im1 |         im1 |         2048 |         2962 |         1.44
im1 |         im1 |         im2 |         2048 |         2019 |         0.98
im1 |         im1 |         im3 |         2048 |         2019 |         0.98
im1 |         im2 |         im1 |         2048 |         2002 |         0.97
im1 |         im2 |         im2 |         2048 |         2003 |         0.97
im1 |         im2 |         im3 |         2048 |         1060 |         0.51
im2 |         im1 |         im1 |         2048 |         2003 |         0.97
im2 |         im1 |         im2 |         2048 |         2002 |         0.97
im2 |         im1 |         im3 |         2048 |         1060 |         0.51
im2 |         im2 |         im1 |         2048 |         2019 |         0.98
im2 |         im2 |         im2 |         2048 |         2962 |         1.44
im2 |         im2 |         im3 |         2048 |         2019 |         0.98

The best configuration:

pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im2 |         im3 |         2048 |         1060 |         0.51

The worst configuration:

pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im1 |         im1 |         2048 |         2962 |         1.44

Perfomance table 1

pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im2 |         im3 |         8 |         98 |         12.24
im1 |         im2 |         im3 |         128 |         113 |         0.88
im1 |         im2 |         im3 |         1024 |         548 |         0.53
im1 |         im2 |         im3 |         2048 |         1060 |         0.51

The best configuration:

pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im2 |         im3 |         2048 |         1060 |         0.51

The worst configuration:

pSrcVec1   |   pSrcVec2   |   pDstVec   |   nSize   |   ticks          |  ticks/elem
---|------|------|------|------|---
im1 |         im2 |         im3 |         8 |         98 |         12.24



##  Требования для работы генератора

1. Уставленные python, [doxygen](http://www.doxygen.nl/download.html), [make](https://sourceforge.net/projects/gnuwin32/files/make/3.81/). 
2. Описанные с помощью тегов Doxygen функции.
3. Сценарии производительности для каждой группы функций.
4. Шаблон сборки будущих тестов.
5. Тестируемые функции (в виде файлов с исходным кодом или библиотеки).


## Подготовка файлов с прототипами тестируемых функций

Все тестируемые функции должны быть описаны с помощью тегов Doxygen.
Использование doxygen-тега \defgroup обязательно.

## Подготовка сценария производительности

Чтобы создать сценарий производительности, нужно Doxygen-описание функции расширить специальными тегами.

Пример:
```
\xmlonly

        <testperf>
	        <param name="src"> im1 im2 </param> 
	        <param name="dst" type="int*"> im1 im2 </param>
	        <param name="nSize"> 8 128 256 </param>
        </testperf>
\endxmlonly
```

##### Описание тегов на основе примера

*\xmlonly* и *\endxmlonly* теги Doxygen для вставки xml-кода.

*\<testperf>* и *\</testperf>* xml-теги, которые ищет генератор для определения сценария производительности.

*\<param>* и *\</param>*  xml-теги для задания аргументов тестируемой функции.
В атрибуте name задается название параметра, в атрибуте type - тип. В самом теге задаются значения параметра.

Атрибут type обязательно нужно указать, если конкретный параметр отсутсвует в прототипе тестируемой функции. (например, этот параметр используется функции инициализации).

##### Тег \<init>
*\<init>* и *\</init>* xml-теги, нужны, чтобы вставить дополнительный код в тест.
Например, для функции:

void nmppsFFT256Fwd_32fcr(const nm32fcr* x, nm32fcr* X, NmppsFFTSpec_32fcr* spec);

требуется предварительная инициализация структуры spec с помощью функции  nmppsFFT256FwdInitAlloc_32fcr. В этом случае сценарий записывается следующим образом:
```
\xmlonly
    <testperf>
		 <init>
		     NmppsFFTSpec_32fcr* spec;
		     nmppsFFT256FwdInitAlloc_32fcr(&amp;spec);
		 </init>
         <param name=" x "> im1 im2 im3 im4 im5 </param>
         <param name=" X "> im1 im2 im3 im4 im5 </param>
		 <size> 256 </size>
    </testperf>
\endxmlonly
```

Полученный код будет выглядить так:
```
  ...
  NmppsFFTSpec_32fcr* spec;
  nmppsFFT256FwdInitAlloc_32fcr(&spec);
  for(int i0 = 0; i0 < 5; i0++) {
    nm32fcr * x = (nm32fcr *)list0[i0];
    for(int i1 = 0; i1 < 5; i1++) {
      nm32fcr * X = (nm32fcr *)list1[i1];
      t1 = clock();
      nmppsFFT256Fwd_32fcr(x, X, spec);
      t2 = clock();
      
    }
  }
  ...
```
> Блок инициализации будет встроен на том уровне вложенных циклов на котором он задан в сценарии. 

##### Тег \<size>
*\<size>* и *\</size>* xml-теги, нужны, чтобы указать количество обрабатываемых функцией данных, если функция не принимает аргумент с количеством данных.

Например, функция с таким прототипом:

void foo(int* pSrc, int* pDst, int width, int height);

принимает аргуметны width и height. Количество обрабатываемых этой функцией данных будет равно width * height. Тогда сценарий производительности будет иметь вид:
```
\xmlonly

        <testperf>
	        <param name="src"> im1 im2 </param> 
	        <param name="dst"> im1 im2 </param>
	        <size> width * height	</size>
        </testperf>
\endxmlonly
```
Тег \<size> может принимать и числовые значения (\<size> 256 \</size>).

## Подготовка шаблона сборки будущего теста перед запуском генератора

Перед запуском генератора необходимо подготовить папку со следующим содержимым:
1. *Makefile*;
2. *Конфиг-файл (например: mc12101brd_nmpu0.cfg)*;
3. *main.cpp*.

##### Требования к Makefile

1. Необходимо убедиться, что *main.cpp* компилируется при вызове *make*.
2. При вызове *make run main.cpp* должен перекомпилироваться и запускаться. 
2. *Makefile* должен подключать к компиляции *main.cpp* все файлы с исходным кодом тестируемых функций.

##### Требования к main.cpp

1. В *main.cpp* обязательно должны быть подключены заголовочные файлы: *time.h, stdio.h, stdlib.h , string.h*. 
2. Должны быть подключены заголовочные файлы, необходимые для работы тестируемой функции.
3. Должны быть описаны массивы(__типа long long__) для входных и выходных данных. Их будут использовать тестируемые функции (названия массивов должны совпадать с названиями, указанными в сценарии производительности).
4. Должна быть создана главная функция *int main() { return 0; }*.


__В папке examples лежит пример подготовленного по описанным правилам проекта.__

## Описание ключей для настройки работы скрипта

### Ключ config

При задании этого ключа скрипт * будет генерировать xml-файлы описанных функций и создавать тесты производительности на основе этих xml-файлов.
В папке, из которой был вызван скрипт, появятся папки со сгененрированными тестами. Там же будет создана папка "doxy" c xml-файлами. 

При использовании этого ключа __необходимо__ передать скрипту дополнительные параметры:

1. *-i* или *--path\_to_headers* - путь к папке с файлами, в которых описаны функции в формате Doxygen.
__Этот параметр не имеет значения по умолчанию и должен быть задан обязательно.__

2. *-b* или *--path\_to_build* - путь к папке, в которой должны лежать Makefile, конфиг-файл и шаблон main.cpp.
__Этот параметр не имеет значения по умолчанию и должен быть задан обязательно.__

3. *-p* или *--point_type* - указывает скрипту для каких функций должны быть сгенерированны тесты (может быть равен *fixed* или *floating*).
Значение по умолчанию: *all*

### Ключ run

При заднии этого ключа скрипт будет запускать сгенерированные тесты (если тесты ранее не были сгенерированы, скрипт об этом собщит).

При использовании этого ключа передать скрипту дополнительные параметры __не нужно__.

### Ключ all

При заднии этого ключа скрипт будет генерировать xml-файлы описанных функций, создавать тесты производительности на основе этих xml-файлов и запускать созданные тесты.
При использовании этого ключа __необходимо__ передать скрипту дополнительные параметры (*-i, -b* и *-p*), см. выше описание ключа config.

### Ключ del

При задании этого ключа в рабочей папке будут удалены все тесты (с префиксом "perf_"), созданные с помощью testperf.

### Ключ outdir

При заднии этого ключа скрипт будет искать в папках со сгенерированными тестами файлы с расширениями *md* и копировать их в папку "tables", изменяя расширение на *h*. Эта папка будет создана в том месте, откуда был запущен скрипт.

При использовании этого ключа передать скрипту дополнительные параметры __не нужно__.

### Параметры для дополнительной настройки скрипта 

1. *--path\_to_cpptests* - путь к папке, в которой будет лежать папка(perf_tests) со сгенерированными тестами.
Значение по умолчанию: *<рабочая папка>*

2. *--path\_to_log* - путь к папке, в которой будет лежать папка(perf\_test\_log) с логами работы скрипта.
Значение по умолчанию: *<рабочая папка>*

3. *--path\_to_doxy_xml* - путь к папке с xml файлами, которые сгенерировал doxygen. На их основе testperf создает тесты.
Значение по умолчанию: *<рабочая папка>*/doxy/xml

 *<рабочая папка>* - папка, из которой запускается скрипт
 
Эти ключи могут быть использованы с любым из ключей, описанных выше.

## Запуск

Сначала нужно запустить install.bat.Этот скрипт создаст переменную окружения(с названием testperf) с путем к testperf.

#### Запуск с ключом config

*testperf config -i \<path> -b \<path>*

#### Запуск с ключом run

*testperf run*

#### Запуск с ключом all

*testperf all -i \<path> -b \<path>*

#### Запуск с ключом del

*testperf del*

#### Запуск с ключом outdir

*testperf outdir*

Порядок задания параметров скрипта не важен. Также не обязательно задавать все параметры. Незаданные параметры будут выставлены по умолчанию.
