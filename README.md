# Генератор С++ тестов для автоматического измерения производительности ASM и С/С++ функций на процессорах NeuroMatrix


## Назначение
На основе заданного для каждой функции сценария данный генератор позволяет замерить время исполнения функций и создать текстовый файл отчета в формате MarkDown.  
Средство позволяет протестировать производительность функции в разных конфигурациях запуска в зависимости от размера данных и взаимного расположений массивов данных в доступных внутренних и внешних банках памяти. По данным тестирования можно судить о полном времени работы функции, об удельной производительности функции в пересчете на входной элемент данных, а также о наиболее оптимальных конфигурациях с точки зрения расположения входных, выходных и временных массивов по банкам памяти. 
Средство полезно при разработке, оптимизации и тестировании функций, а также для подготовки данных по производительности для импорта в техническую документацию.  
Средство  поддерживает автоматизацию для обработки большого кол-ва функций, генерации тестов и их последующего запуска. 
Описанные сценария тестирования задаются непосредственно в заголовочных файлах в виде комментариев к функциям в формате Doxygen. 
Результат замеров выдается в табличном виде в формате MarkDown.

## Как это работает
Допустим имеется функция сложения двух векторов:
```
void nmppsAdd_32f(const nm32f* pSrcVec1, const nm32f* pSrcVec2, nm32f* pDstVec, int nSize);
```

и есть несколько буферов , расположенных в разных банках внутренней памяти (imu1-imu6), и внешней DDR (emi):
```
#pragma data_section ".data_imu1"
    long long im1[2048];
#pragma data_section ".data_imu2"
    long long im2[2048];
#pragma data_section ".data_imu3"
    long long im3[2048];
#pragma data_section ".data_imu4"
    long long im4[2048];
#pragma data_section ".data_imu5"
    long long im5[2048];
#pragma data_section ".data_imu6"
    long long im6[2048];

#pragma data_section ".data_emi"
    long long emi[2048];
```

Задача 1: требуется замерять время исполнения функции в следующих вариантах памятей при фиксированном размере, чтобы найти лучшую конфигурацию :

nmppsAdd_32f(im1,im1,256);  
nmppsAdd_32f(im1,im2,256);  
nmppsAdd_32f(im2,im1,256);  
nmppsAdd_32f(im1,emi,256);  
nmppsAdd_32f(emi,emi,256);  
nmppsAdd_32f(emi,emi1,256);  

Задача 2: требуется определить скорость работы функции в зависимости от размера данных, при фиксированном расположении :

nmppsAdd_32f(im1,im2,8;  
nmppsAdd_32f(im1,im2,16);  
nmppsAdd_32f(im2,im1,32);  
nmppsAdd_32f(im1,emi,256);  
nmppsAdd_32f(emi,emi,1024);  


В случае ручного выполнения  данной задачи (написание тестов, сборка , запуск , сбор информации) процесс будет очень трудоемким, в котором при каждой модификации кода потребуется повторный перезапуск тестов. 
Решение данной  задачи  может быть полностью автоматизировано с помощью генератора тестов test_perf следующим образом:

К функции составляется описание ее параметров в формате Doxygen, в которое в XML-виде добавляются сценарии, по которым необходимо перебирать переменные :

```
/**
\defgroup nmppsAdd_f nmppsAdd
\brief Сложение двух векторов.
\param pSrcVec1 [in] Первый входной вектор.
\param pSrcVec2 [in] Второй входной вектор.
\param nSize [in] Размер вектора в элементах.
\retval pDstVec [out] Результирующий вектор.
\par
\xmlonly
	<testperf>
		<param name="src"> im1 im2 emi </param> 
		<param name="dst" type="int*"> im1 im2 emi</param>
		<param name="nSize"> 256 </param>
	</testperf>
	<testperf>
		<param name="src"> im1 </param> 
		<param name="dst" type="int*"> im2 </param>
		<param name="nSize"> 8 16 32 256 1024 </param>
	</testperf>
\endxmlonly
*/
//! \{
void nmppsAdd_32f(const nm32f* pSrcVec1, const nm32f* pSrcVec2, nm32f* pDstVec, int nSize);
//! \}
```

Создается проект-заготовка теста, состоящего из пустой функции main() , сборочного файла Makefile и сборочного конфигурационного файла (cfg или ld). Программа должна собираться и исполняться , командам make и make run соответственно. 
```
#include "nmpp.h"
#include "time.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"

#pragma data_section ".data_imu1"
    long long im1[2048];
#pragma data_section ".data_imu2"
    long long im2[2048];
#pragma data_section ".data_imu3"
    long long im3[2048];
#pragma data_section ".data_imu4"
    long long im4[2048];
#pragma data_section ".data_imu5"
    long long im5[2048];
#pragma data_section ".data_imu6"
    long long im6[2048];

#pragma data_section ".data_emi"
    long long emi[2048];

int main()
{
  return 0;
}
```

Далее запускается генератор test_perf c указанием  пути к заголовочным файлам и папке с проектом-заготовкой:
```
testperf config -i ..\include  -b make_mc12101_nmpu0
```

Генератор test_perf запустит Doxygen и затем создаст для всех найденных (описанных в Doxygen) функций тестовые проекты. В нашем случае для функции nmppsAdd_32f создаст папку \perf_nmppsAdd_32f  .

После генерации тестов сборка и запуск осуществляется командой 
```
testperf run
```

Test_perf запустит все имеющиеся тесты и выдаст таблицу с замерами производительности 
в виде :


Perfomance table 0

x   |   X   |   ticks          |  ticks/elem
---|------|------|---
im1 |         im1 |         1778 |         6.94
im1 |         im2 |         1722 |         6.72
im1 |         im3 |         1722 |         6.72
im1 |         im4 |         1722 |         6.72
im1 |         im5 |         1722 |         6.72
im2 |         im1 |         1914 |         7.47
im2 |         im2 |         1858 |         7.25
im2 |         im3 |         1858 |         7.25
im2 |         im4 |         1858 |         7.25
im2 |         im5 |         1858 |         7.25
im3 |         im1 |         1910 |         7.46
im3 |         im2 |         1854 |         7.24
im3 |         im3 |         1854 |         7.24
im3 |         im4 |         1854 |         7.24
im3 |         im5 |         1854 |         7.24
im4 |         im1 |         1880 |         7.34
im4 |         im2 |         1824 |         7.12
im4 |         im3 |         1824 |         7.12
im4 |         im4 |         1824 |         7.12
im4 |         im5 |         1824 |         7.12
im5 |         im1 |         1778 |         6.94
im5 |         im2 |         1722 |         6.72
im5 |         im3 |         1722 |         6.72
im5 |         im4 |         1722 |         6.72
im5 |         im5 |         1722 |         6.72

The best configuration:

x   |   X   |   ticks          |  ticks/elem
---|------|------|---
im1 |         im2 |         1722 |         6.72

The worst configuration:

x   |   X   |   ticks          |  ticks/elem
---|------|------|---
im2 |         im1 |         1914 |         7.47
  
```
void nmppsFFT256Fwd_32fcr(const nm32fcr *x, nm32fcr *X, NmppsFFTSpec_32fcr *spec);

```

##  Требования для работы генератора

1. Уставленные python, [doxygen](http://www.doxygen.nl/download.html), [make](https://sourceforge.net/projects/gnuwin32/files/make/3.81/). 
2. Описанные с помощью тегов Doxygen функции.
3. Сценарии производительности для каждой группы функций.
4. Шаблон сборки будущих тестов.
5. Тестируемые функции (в виде файлов с исходным кодом или библиотеки).


## Подготовка файлов с прототипами тестируемых функций

Все тестируемые функции должны быть описаны с помощью тегов Doxygen.
Использование doxygen-тега \defgroup обязательно.

## Подготовка сценария производительности

Чтобы создать сценарий производительности, нужно Doxygen-описание функции расширить специальными тегами.

Пример:
```
\xmlonly

        <testperf>
	        <param name="src"> im1 im2 </param> 
	        <param name="dst" type="int*"> im1 im2 </param>
	        <param name="nSize"> 8 128 256 </param>
        </testperf>
\endxmlonly
```

##### Описание тегов на основе примера

*\xmlonly* и *\endxmlonly* теги Doxygen для вставки xml-кода.

*\<testperf>* и *\</testperf>* xml-теги, которые ищет генератор для определения сценария производительности.

*\<param>* и *\</param>*  xml-теги для задания аргументов тестируемой функции.
В атрибуте name задается название параметра, в атрибуте type - тип. В самом теге задаются значения параметра.

Атрибут type обязательно нужно указать, если конкретный параметр отсутсвует в прототипе тестируемой функции. (например, этот параметр используется функции инициализации).

##### Тег \<init>
*\<init>* и *\</init>* xml-теги, нужны, чтобы вставить дополнительный код в тест.
Например, для функции:

void fft16(float* src, float*, FftSpec* fftspec);

должен быть заранее проинициализирован fftspec с помощью функции инициализации.
```
\xmlonly

        <testperf>
	        <param name="src"> im1 im2 </param>
	        <param name="dst"> im1 im2 </param>
	         <init> 
	         FftSpec* spec;
	         initFunc(&spec);	
	         </init>
	        <size> width * height	</size>
        </testperf>
\endxmlonly
```
##### Тег \<size>
*\<size>* и *\</size>* xml-теги, нужны, чтобы указать количество обрабатываемых функцией данных, если функция не принимает аргумент с количеством данных.

Например, функция с таким прототипом:

void foo(int* pSrc, int* pDst, int width, int height);

принимает аргуметны width и height. Количество обрабатываемых этой функцией данных будет равно width * height. Тогда сценарий производительности будет иметь вид:
```
\xmlonly

        <testperf>
	        <param name="src"> im1 im2 </param> 
	        <param name="dst"> im1 im2 </param>
	        <size> width * height	</size>
        </testperf>
\endxmlonly
```
Тег \<size> может принимать и числовые значения (\<size> 256 \</size>).

## Подготовка шаблона сборки будущего теста перед запуском генератора

Перед запуском генератора необходимо подготовить папку со следующим содержимым:
1. *Makefile*;
2. *Конфиг-файл (например: mc12101brd_nmpu0.cfg)*;
3. *main.cpp*.

##### Требования к Makefile

1. Необходимо убедиться, что *main.cpp* компилируется при вызове *make*.
2. При вызове *make run main.cpp* должен перекомпилироваться и запускаться. 
2. *Makefile* должен подключать к компиляции *main.cpp* все файлы с исходным кодом тестируемых функций.

##### Требования к main.cpp

1. В *main.cpp* обязательно должны быть подключены заголовочные файлы: *time.h, stdio.h, stdlib.h , string.h*. 
2. Должны быть подключены заголовочные файлы, необходимые для работы тестируемой функции.
3. Должны быть описаны массивы(__типа long long__) для входных и выходных данных. Их будут использовать тестируемые функции (названия массивов должны совпадать с названиями, указанными в сценарии производительности).
4. Должна быть создана главная функция *int main() { return 0; }*.


__В папке examples лежит пример подготовленного по описанным правилам проекта.__

## Описание ключей для настройки работы скрипта

### Ключ config

При задании этого ключа скрипт будет генерировать xml-файлы описанных функций и создавать тесты производительности на основе этих xml-файлов.
В папке, из которой был вызван скрипт, появятся папки со сгененрированными тестами. Там же будет создана папка "doxy" c xml-файлами. 

При использовании этого ключа __необходимо__ передать скрипту дополнительные параметры:

1. *-i* или *--path\_to_headers* - путь к папке с файлами, в которых описаны функции в формате Doxygen.
__Этот параметр не имеет значения по умолчанию и должен быть задан обязательно.__

2. *-b* или *--path\_to_build* - путь к папке, в которой должны лежать Makefile, конфиг-файл и шаблон main.cpp.
__Этот параметр не имеет значения по умолчанию и должен быть задан обязательно.__

3. *-p* или *--point_type* - указывает скрипту для каких функций должны быть сгенерированны тесты (может быть равен *fixed* или *floating*).
Значение по умолчанию: *all*

### Ключ run

При заднии этого ключа скрипт будет запускать сгенерированные тесты (если тесты ранее не были сгенерированы, скрипт об этом собщит).

При использовании этого ключа передать скрипту дополнительные параметры __не нужно__.

### Ключ all

При заднии этого ключа скрипт будет генерировать xml-файлы описанных функций, создавать тесты производительности на основе этих xml-файлов и запускать созданные тесты.
При использовании этого ключа __необходимо__ передать скрипту дополнительные параметры (*-i, -b* и *-p*), см. выше описание ключа config.

### Ключ del

При задании этого ключа в рабочей папке будут удалены все тесты (с префиксом "perf_"), созданные с помощью testperf.

### Ключ outdir

При заднии этого ключа скрипт будет искать в папках со сгенерированными тестами файлы с расширениями *md* и копировать их в папку "tables", изменяя расширение на *h*. Эта папка будет создана в том месте, откуда был запущен скрипт.

При использовании этого ключа передать скрипту дополнительные параметры __не нужно__.

### Параметры для дополнительной настройки скрипта 

1. *--path\_to_cpptests* - путь к папке, в которой будет лежать папка(perf_tests) со сгенерированными тестами.
Значение по умолчанию: *<рабочая папка>*

2. *--path\_to_log* - путь к папке, в которой будет лежать папка(perf\_test\_log) с логами работы скрипта.
Значение по умолчанию: *<рабочая папка>*

3. *--path\_to_doxy_xml* - путь к папке с xml файлами, которые сгенерировал doxygen. На их основе testperf создает тесты.
Значение по умолчанию: *<рабочая папка>*/doxy/xml

 *<рабочая папка>* - папка, из которой запускается скрипт
 
Эти ключи могут быть использованы с любым из ключей, описанных выше.

## Запуск

Сначала нужно запустить install.bat.Этот скрипт создаст переменную окружения(с названием testperf) с путем к testperf.

#### Запуск с ключом config

*testperf config -i \<path> -b \<path>*

#### Запуск с ключом run

*testperf run*

#### Запуск с ключом all

*testperf all -i \<path> -b \<path>*

#### Запуск с ключом del

*testperf del*

#### Запуск с ключом outdir

*testperf outdir*

Порядок задания параметров скрипта не важен. Также не обязательно задавать все параметры. Незаданные параметры будут выставлены по умолчанию.
